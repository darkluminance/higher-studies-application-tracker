// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: timeline.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const getTimeline = `-- name: GetTimeline :many
WITH 
universities_cte AS (
    SELECT 
        'University' AS type,
        u.name AS name,
        NULL AS university_name,
        NULL AS designation,
        u.early_deadline AS date
    FROM 
        university u
    WHERE 
        u.user_id = $1
    ORDER BY 
        u.early_deadline ASC
    LIMIT 4
),

interviews_cte AS (
    SELECT 
        'Interview' AS type,
        f.name AS name,
        u.name AS university_name,
        f.designation AS designation,
        i.date
    FROM 
        interview i
    LEFT JOIN faculty f ON i.faculty_id = f.id
    LEFT JOIN university u ON f.university_id = u.id
    WHERE 
        i.user_id = $1
    ORDER BY 
        i.date ASC
    LIMIT 4
),

timeline_cte AS (
    SELECT type, name, university_name, designation, date FROM universities_cte
    UNION ALL
    SELECT type, name, university_name, designation, date FROM interviews_cte
    ORDER BY date ASC
),

applied_university_count_cte AS (
    SELECT 
        COALESCE(CAST(SUM(CASE WHEN application_status = 'APPLIED' THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0), 0) AS appliedUniversityCount
    FROM 
        university_application ua
    WHERE 
        ua.user_id = $1
),

replied_mails_count_cte AS (
    SELECT 
        COALESCE(CAST(SUM(CASE WHEN is_mail_replied = TRUE THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0), 0) AS repliedMailsCount
    FROM 
        mail m
    WHERE 
        m.user_id = $1
),

university_application_count_cte AS (
    SELECT 
        COALESCE(COUNT(*), 0) AS universityApplicationCount
    FROM 
        university_application uaa
    WHERE 
        uaa.user_id = $1
),

recommendation_count_cte AS (
    SELECT 
        COALESCE(CAST(SUM(CASE WHEN is_lor_submitted = TRUE THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0), 0) AS recommendationCount
    FROM 
        recommender_status rs
    WHERE 
        rs.user_id = $1
)

SELECT 
    COALESCE((SELECT JSON_AGG(t)::TEXT FROM timeline_cte t), '[]') AS timeline,
    (SELECT appliedUniversityCount FROM applied_university_count_cte) AS appliedUniversityCount,
    (SELECT repliedMailsCount FROM replied_mails_count_cte) AS repliedMailsCount,
    (SELECT universityApplicationCount FROM university_application_count_cte) AS universityApplicationCount,
    (SELECT recommendationCount FROM recommendation_count_cte) AS recommendationCount
`

type GetTimelineRow struct {
	Timeline                   interface{}
	Applieduniversitycount     interface{}
	Repliedmailscount          interface{}
	Universityapplicationcount interface{}
	Recommendationcount        interface{}
}

func (q *Queries) GetTimeline(ctx context.Context, userID uuid.UUID) ([]GetTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeline, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimelineRow
	for rows.Next() {
		var i GetTimelineRow
		if err := rows.Scan(
			&i.Timeline,
			&i.Applieduniversitycount,
			&i.Repliedmailscount,
			&i.Universityapplicationcount,
			&i.Recommendationcount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
